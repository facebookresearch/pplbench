{"version":3,"sources":["../src/matcher/mention-matcher.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,OAAO,EAAiB,MAAM,WAAW,CAAC;AACnD,OAAO,EAAE,4BAA4B,EAAE,MAAM,cAAc,CAAC;AAE5D,OAAO,EAAE,YAAY,EAAE,MAAM,wBAAwB,CAAC;AAGtD,gFAAgF;AAChF,8EAA8E;AAC9E,2EAA2E;AAC3E,6GAA6G;AAC7G,gFAAgF;AAChF,IAAM,YAAY,GAAG,IAAI,MAAM,CAAE,QAAM,4BAA4B,oBAAe,4BAA4B,OAAI,EAAE,GAAG,CAAE,CAAC,CAAE,2EAA2E;AACvM,IAAM,cAAc,GAAG,IAAI,MAAM,CAAE,SAAO,4BAA4B,oBAAe,4BAA4B,OAAI,EAAE,GAAG,CAAE,CAAC,CAAE,2EAA2E;AAC1M,IAAM,eAAe,GAAG,IAAI,MAAM,CAAE,UAAQ,4BAA4B,qBAAgB,4BAA4B,OAAI,EAAE,GAAG,CAAE,CAAC,CAAE,2EAA2E;AAC7M,IAAM,gBAAgB,GAAG,IAAI,MAAM,CAAE,IAAI,GAAG,4BAA4B,GAAG,GAAG,CAAE,CAAC;AAEjF;;;;;GAKG;AACH;IAAoC,0CAAO;IAqC1C;;;;OAIG;IACH,wBAAa,GAAyB;QAAtC,YACC,kBAAO,GAAG,CAAE,SAGZ;QA5CD;;;;;;WAMG;QACO,iBAAW,GAAoB,SAAS,CAAC,CAAE,gGAAgG;QAErJ;;;;;;;WAOG;QACgB,oBAAc,GAA4B;YAC5D,SAAS,EAAE,YAAY;YACvB,WAAW,EAAE,cAAc;YAC3B,YAAY,EAAE,eAAe;SAC7B,CAAC;QAEF;;;;;;;;WAQG;QACgB,sBAAgB,GAAG,gBAAgB,CAAC;QAWtD,KAAI,CAAC,WAAW,GAAG,GAAG,CAAC,WAAW,CAAC;;IACpC,CAAC;IAGD;;OAEG;IACH,qCAAY,GAAZ,UAAc,IAAY;QACzB,IAAI,WAAW,GAAG,IAAI,CAAC,WAAW,EAC9B,YAAY,GAAG,IAAI,CAAC,cAAc,CAAE,IAAI,CAAC,WAAW,CAAE,EACtD,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,EACxC,UAAU,GAAG,IAAI,CAAC,UAAU,EAC5B,OAAO,GAAY,EAAE,EACrB,KAA6B,CAAC;QAElC,IAAI,CAAC,YAAY,EAAE;YAClB,OAAO,OAAO,CAAC;SACf;QAED,OAAO,CAAE,KAAK,GAAG,YAAY,CAAC,IAAI,CAAE,IAAI,CAAE,CAAE,KAAK,IAAI,EAAG;YACvD,IAAI,MAAM,GAAG,KAAK,CAAC,KAAK,EACpB,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAE,MAAM,GAAG,CAAC,CAAE,CAAC;YAEzC,8EAA8E;YAC9E,4EAA4E;YAC5E,yCAAyC;YACzC,IAAI,MAAM,KAAK,CAAC,IAAI,gBAAgB,CAAC,IAAI,CAAE,QAAQ,CAAE,EAAG;gBACvD,IAAI,WAAW,GAAG,KAAK,CAAE,CAAC,CAAE,CAAC,OAAO,CAAE,OAAO,EAAE,EAAE,CAAE,EAAE,uBAAuB;gBACxE,OAAO,GAAG,WAAW,CAAC,KAAK,CAAE,CAAC,CAAE,CAAC,CAAE,+CAA+C;gBAEtF,OAAO,CAAC,IAAI,CAAE,IAAI,YAAY,CAAE;oBAC/B,UAAU,EAAM,UAAU;oBAC1B,WAAW,EAAK,WAAW;oBAC3B,MAAM,EAAU,MAAM;oBACtB,WAAW,EAAK,WAAW;oBAC3B,OAAO,EAAS,OAAO;iBACvB,CAAE,CAAE,CAAC;aACN;SACD;QAED,OAAO,OAAO,CAAC;IAChB,CAAC;IAEF,qBAAC;AAAD,CAxFA,AAwFC,CAxFmC,OAAO,GAwF1C","file":"mention-matcher.js","sourcesContent":["import { Matcher, MatcherConfig } from \"./matcher\";\nimport { alphaNumericAndMarksCharsStr } from \"../regex-lib\";\nimport { MentionServices } from \"../autolinker\";\nimport { MentionMatch } from \"../match/mention-match\";\nimport { Match } from \"../match/match\";\n\n// RegExp objects which are shared by all instances of MentionMatcher. These are\n// here to avoid re-instantiating the RegExp objects if `Autolinker.link()` is\n// called multiple times, thus instantiating MentionMatcher and its RegExp \n// objects each time (which is very expensive - see https://github.com/gregjacobs/Autolinker.js/issues/314). \n// See descriptions of the properties where they are used for details about them\nconst twitterRegex = new RegExp( `@[_${alphaNumericAndMarksCharsStr}]{1,50}(?![_${alphaNumericAndMarksCharsStr}])`, 'g' );  // lookahead used to make sure we don't match something above 50 characters\nconst instagramRegex = new RegExp( `@[_.${alphaNumericAndMarksCharsStr}]{1,30}(?![_${alphaNumericAndMarksCharsStr}])`, 'g' );  // lookahead used to make sure we don't match something above 30 characters\nconst soundcloudRegex = new RegExp( `@[-_.${alphaNumericAndMarksCharsStr}]{1,50}(?![-_${alphaNumericAndMarksCharsStr}])`, 'g' );  // lookahead used to make sure we don't match something above 50 characters\nconst nonWordCharRegex = new RegExp( '[^' + alphaNumericAndMarksCharsStr + ']' );\n\n/**\n * @class Autolinker.matcher.Mention\n * @extends Autolinker.matcher.Matcher\n *\n * Matcher to find/replace username matches in an input string.\n */\nexport class MentionMatcher extends Matcher {\n\n\t/**\n\t * @cfg {'twitter'/'instagram'/'soundcloud'} protected\n\t * \n\t * The name of service to link @mentions to.\n\t * \n\t * Valid values are: 'twitter', 'instagram', or 'soundcloud'\n\t */\n\tprotected serviceName: MentionServices = 'twitter';  // default value just to get the above doc comment in the ES5 output and documentation generator\n\n\t/**\n\t * Hash of regular expression to match username handles. Example match:\n\t *\n\t *     @asdf\n\t *\n\t * @private\n\t * @property {Object} matcherRegexes\n\t */\n\tprotected readonly matcherRegexes: {[key: string]: RegExp} = {\n\t\t'twitter': twitterRegex,\n\t\t'instagram': instagramRegex,\n\t\t'soundcloud': soundcloudRegex\n\t};\n\n\t/**\n\t * The regular expression to use to check the character before a username match to\n\t * make sure we didn't accidentally match an email address.\n\t *\n\t * For example, the string \"asdf@asdf.com\" should not match \"@asdf\" as a username.\n\t *\n\t * @private\n\t * @property {RegExp} nonWordCharRegex\n\t */\n\tprotected readonly nonWordCharRegex = nonWordCharRegex;\n\n\n\t/**\n\t * @method constructor\n\t * @param {Object} cfg The configuration properties for the Match instance,\n\t *   specified in an Object (map).\n\t */\n\tconstructor( cfg: MentionMatcherConfig ) {\n\t\tsuper( cfg );\n\n\t\tthis.serviceName = cfg.serviceName;\n\t}\n\n\n\t/**\n\t * @inheritdoc\n\t */\n\tparseMatches( text: string ) {\n\t\tlet serviceName = this.serviceName,\n\t\t    matcherRegex = this.matcherRegexes[ this.serviceName ],\n\t\t    nonWordCharRegex = this.nonWordCharRegex,\n\t\t    tagBuilder = this.tagBuilder,\n\t\t    matches: Match[] = [],\n\t\t    match: RegExpExecArray | null;\n\n\t\tif (!matcherRegex) {\n\t\t\treturn matches;\n\t\t}\n\n\t\twhile( ( match = matcherRegex.exec( text ) ) !== null ) {\n\t\t\tlet offset = match.index,\n\t\t\t    prevChar = text.charAt( offset - 1 );\n\n\t\t\t// If we found the match at the beginning of the string, or we found the match\n\t\t\t// and there is a whitespace char in front of it (meaning it is not an email\n\t\t\t// address), then it is a username match.\n\t\t\tif( offset === 0 || nonWordCharRegex.test( prevChar ) ) {\n\t\t\t\tlet matchedText = match[ 0 ].replace( /\\.+$/g, '' ), // strip off trailing .\n\t\t\t\t    mention = matchedText.slice( 1 );  // strip off the '@' character at the beginning\n\n\t\t\t\tmatches.push( new MentionMatch( {\n\t\t\t\t\ttagBuilder    : tagBuilder,\n\t\t\t\t\tmatchedText   : matchedText,\n\t\t\t\t\toffset        : offset,\n\t\t\t\t\tserviceName   : serviceName,\n\t\t\t\t\tmention       : mention\n\t\t\t\t} ) );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t}\n\n}\n\n\nexport interface MentionMatcherConfig extends MatcherConfig {\n\tserviceName: MentionServices\n}"]}
{"version":3,"sources":["../src/matcher/url-match-validator.ts"],"names":[],"mappings":"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","file":"url-match-validator.js","sourcesContent":["import { alphaCharsStr } from \"../regex-lib\";\n\n/**\n * @private\n * @class Autolinker.matcher.UrlMatchValidator\n * @singleton\n *\n * Used by Autolinker to filter out false URL positives from the\n * {@link Autolinker.matcher.Url UrlMatcher}.\n *\n * Due to the limitations of regular expressions (including the missing feature\n * of look-behinds in JS regular expressions), we cannot always determine the\n * validity of a given match. This class applies a bit of additional logic to\n * filter out any false positives that have been matched by the\n * {@link Autolinker.matcher.Url UrlMatcher}.\n */\nexport class UrlMatchValidator {\n\n\t/**\n\t * Regex to test for a full protocol, with the two trailing slashes. Ex: 'http://'\n\t *\n\t * @private\n\t * @property {RegExp} hasFullProtocolRegex\n\t */\n\tstatic hasFullProtocolRegex = /^[A-Za-z][-.+A-Za-z0-9]*:\\/\\//;\n\n\t/**\n\t * Regex to find the URI scheme, such as 'mailto:'.\n\t *\n\t * This is used to filter out 'javascript:' and 'vbscript:' schemes.\n\t *\n\t * @private\n\t * @property {RegExp} uriSchemeRegex\n\t */\n\tstatic uriSchemeRegex = /^[A-Za-z][-.+A-Za-z0-9]*:/;\n\n\t/**\n\t * Regex to determine if at least one word char exists after the protocol (i.e. after the ':')\n\t *\n\t * @private\n\t * @property {RegExp} hasWordCharAfterProtocolRegex\n\t */\n\tstatic hasWordCharAfterProtocolRegex = new RegExp(\":[^\\\\s]*?[\" + alphaCharsStr + \"]\");\n\n\t/**\n\t * Regex to determine if the string is a valid IP address\n\t *\n\t * @private\n\t * @property {RegExp} ipRegex\n\t */\n\tstatic ipRegex = /[0-9][0-9]?[0-9]?\\.[0-9][0-9]?[0-9]?\\.[0-9][0-9]?[0-9]?\\.[0-9][0-9]?[0-9]?(:[0-9]*)?\\/?$/;\n\n\t/**\n\t * Determines if a given URL match found by the {@link Autolinker.matcher.Url UrlMatcher}\n\t * is valid. Will return `false` for:\n\t *\n\t * 1) URL matches which do not have at least have one period ('.') in the\n\t *    domain name (effectively skipping over matches like \"abc:def\").\n\t *    However, URL matches with a protocol will be allowed (ex: 'http://localhost')\n\t * 2) URL matches which do not have at least one word character in the\n\t *    domain name (effectively skipping over matches like \"git:1.0\").\n\t *    However, URL matches with a protocol will be allowed (ex: 'intra-net://271219.76')\n\t * 3) A protocol-relative url match (a URL beginning with '//') whose\n\t *    previous character is a word character (effectively skipping over\n\t *    strings like \"abc//google.com\")\n\t *\n\t * Otherwise, returns `true`.\n\t *\n\t * @param {String} urlMatch The matched URL, if there was one. Will be an\n\t *   empty string if the match is not a URL match.\n\t * @param {String} protocolUrlMatch The match URL string for a protocol\n\t *   match. Ex: 'http://yahoo.com'. This is used to match something like\n\t *   'http://localhost', where we won't double check that the domain name\n\t *   has at least one '.' in it.\n\t * @return {Boolean} `true` if the match given is valid and should be\n\t *   processed, or `false` if the match is invalid and/or should just not be\n\t *   processed.\n\t */\n\tstatic isValid( urlMatch: string, protocolUrlMatch: string ) {\n\t\tif(\n\t\t\t( protocolUrlMatch && !this.isValidUriScheme( protocolUrlMatch ) ) ||\n\t\t\tthis.urlMatchDoesNotHaveProtocolOrDot( urlMatch, protocolUrlMatch ) ||    // At least one period ('.') must exist in the URL match for us to consider it an actual URL, *unless* it was a full protocol match (like 'http://localhost')\n\t\t\t(this.urlMatchDoesNotHaveAtLeastOneWordChar( urlMatch, protocolUrlMatch ) && // At least one letter character must exist in the domain name after a protocol match. Ex: skip over something like \"git:1.0\"\n\t\t\t   !this.isValidIpAddress( urlMatch )) || // Except if it's an IP address\n\t\t\tthis.containsMultipleDots( urlMatch )\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\n\tstatic isValidIpAddress( uriSchemeMatch: string ) {\n\t\tlet newRegex = new RegExp( this.hasFullProtocolRegex.source + this.ipRegex.source );\n\t\tlet uriScheme = uriSchemeMatch.match( newRegex );\n\n\t\treturn uriScheme !== null;\n\t}\n\n\tprivate static containsMultipleDots( urlMatch: string ) {\n\t\tvar stringBeforeSlash = urlMatch;\n\t\tif (this.hasFullProtocolRegex.test(urlMatch)) {\n\t\t\tstringBeforeSlash = urlMatch.split('://')[1];\n\t\t}\n\t\treturn stringBeforeSlash.split('/')[0].indexOf(\"..\") > -1;\n\t}\n\n\t/**\n\t * Determines if the URI scheme is a valid scheme to be autolinked. Returns\n\t * `false` if the scheme is 'javascript:' or 'vbscript:'\n\t *\n\t * @private\n\t * @param {String} uriSchemeMatch The match URL string for a full URI scheme\n\t *   match. Ex: 'http://yahoo.com' or 'mailto:a@a.com'.\n\t * @return {Boolean} `true` if the scheme is a valid one, `false` otherwise.\n\t */\n\tstatic isValidUriScheme( uriSchemeMatch: string ) {\n\t\tlet uriSchemeMatchArr = uriSchemeMatch.match( this.uriSchemeRegex ),\n\t\t    uriScheme = uriSchemeMatchArr && uriSchemeMatchArr[ 0 ].toLowerCase();\n\n\t\treturn ( uriScheme !== 'javascript:' && uriScheme !== 'vbscript:' );\n\t}\n\n\n\t/**\n\t * Determines if a URL match does not have either:\n\t *\n\t * a) a full protocol (i.e. 'http://'), or\n\t * b) at least one dot ('.') in the domain name (for a non-full-protocol\n\t *    match).\n\t *\n\t * Either situation is considered an invalid URL (ex: 'git:d' does not have\n\t * either the '://' part, or at least one dot in the domain name. If the\n\t * match was 'git:abc.com', we would consider this valid.)\n\t *\n\t * @private\n\t * @param {String} urlMatch The matched URL, if there was one. Will be an\n\t *   empty string if the match is not a URL match.\n\t * @param {String} protocolUrlMatch The match URL string for a protocol\n\t *   match. Ex: 'http://yahoo.com'. This is used to match something like\n\t *   'http://localhost', where we won't double check that the domain name\n\t *   has at least one '.' in it.\n\t * @return {Boolean} `true` if the URL match does not have a full protocol,\n\t *   or at least one dot ('.') in a non-full-protocol match.\n\t */\n\tstatic urlMatchDoesNotHaveProtocolOrDot( urlMatch: string, protocolUrlMatch: string ) {\n\t\treturn ( !!urlMatch && ( !protocolUrlMatch || !this.hasFullProtocolRegex.test( protocolUrlMatch ) ) && urlMatch.indexOf( '.' ) === -1 );\n\t}\n\n\n\t/**\n\t * Determines if a URL match does not have either:\n\t *\n\t * a) a full protocol (i.e. 'http://'), or\n\t * b) at least one word character after the protocol (i.e. in the domain name)\n\t *\n\t * At least one letter character must exist in the domain name after a\n\t * protocol match. Ex: skip over something like \"git:1.0\"\n\t *\n\t * @private\n\t * @param {String} urlMatch The matched URL, if there was one. Will be an\n\t *   empty string if the match is not a URL match.\n\t * @param {String} protocolUrlMatch The match URL string for a protocol\n\t *   match. Ex: 'http://yahoo.com'. This is used to know whether or not we\n\t *   have a protocol in the URL string, in order to check for a word\n\t *   character after the protocol separator (':').\n\t * @return {Boolean} `true` if the URL match does not have a full protocol, or\n\t * at least one word character in it, `false` otherwise.\n\t */\n\tstatic urlMatchDoesNotHaveAtLeastOneWordChar( urlMatch: string, protocolUrlMatch: string ) {\n\t\tif( urlMatch && protocolUrlMatch ) {\n\t\t\treturn !this.hasFullProtocolRegex.test( protocolUrlMatch ) && !this.hasWordCharAfterProtocolRegex.test( urlMatch );\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n}"]}